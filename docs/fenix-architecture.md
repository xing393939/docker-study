### 《凤凰架构》

#### 参考资料
* [《凤凰架构》在线版](http://icyfenix.cn/)

#### 第一部分，演进中的架构（架构涉及到哪些标准方案）
* 1990提出分布式运算环境，以失败告终
  * 受限于机器的硬件条件，不能做到“如同本地调用一般简单透明的”分布式系统
* 单体系统时代
  * 优点：程序在同一机器同一进程，程序简单高效
  * 缺点1：损失了各个功能模块的自治隔离能力
  * 缺点2：靠希望每一处的代码都尽量可靠、不出错来构建可靠系统
  * （可靠系统是从“追求尽量不出错”到正视“出错是必然”的观念转变）
* SOA时代（Service-Oriented Architecture，面向服务的架构）
  * 三个有代表性的架构：
    * 信息孤岛系统：各个系统完全独立（现实是系统之间需要连接）
    * 微内核架构：一个核心模块和若干插件模块（插件模块之间有时也需要连接）
    * 事件驱动架构：一个事件管道和若干个子系统，每个子系统可以订阅和处理自己感兴趣的事件（缺点？）
  * SOA架构的“更具体”：WSDL发布服务，UDDI注册服务，EBS实现子系统的通讯
  * SOA架构的“更系统”：SOA不仅关心技术，还关注需求、流程、管理
  * SOA架构的缺点1：需要精密的流程和理论，只有专业人员才能驾驭
  * SOA架构的缺点2：很难作为一种广泛普适性的软件架构风格来推广
* 微服务的九个核心特征，以区别SOA：
  * 围绕业务去构建组织：根据康威定律，如果把归属于同一个产品的功能分在两个团队，将造成沟通成本
  * 分散治理：服务归属于哪个团队，哪个团队就要全权负责
  * 通过服务来实现独立自治的组件：对外提供服务而不是类库
  * 产品化思维
  * 数据去中心化：不同的服务使用独立的数据库
  * 强终端弱管道：服务之间的通讯协议要简单，不像SOAP那样复杂
  * 容错性设计：允许服务出错，同时做好容错性设计
  * 演进式架构：服务是可以被替代的，存在不可替代的服务是架构设计的缺陷
  * 基础设施自动化：减少CI/CD的复杂性
* 后微服务时代：解决微服务架构问题，从纯软件层面应对到软硬件一体合力应对  
* 无服务时代：后端设施（数据库、消息队列、日志、存储等）和函数

#### 第二部分，架构师的视角（理清分布式系统中新的挑战与应对）
* 访问远程服务
  * 进程间通讯：管道、信号、信号量、消息队列、共享内存、UnixDomainSocket
  * RPC的三个问题：如何表示数据(JSON/Protocol Buffer)、如何传递数据(SOAP/Http)、如何确定方法(WSDL/JSON-WSP)
* RPC经历的几个阶段：
  * W3C Web Service：除了SOAP\WSDL\UDDI外，还有解决事务、一致性、事件、通知的协议。协议太复杂，对开发者是负担
  * 不再最求大而全，分裂的RPC：
    * 朝着面向对象发展
    * 朝着性能发展：gRPC基于Protocol Buffer和Http2、Thrift是自己的序列化和基于TCP协议
    * 朝着简化发展：JSON-RPC
  * 不仅仅负责调用远程服务，还负责管理远程服务(负载均衡、服务注册、可观察性等等)
  * （分布式系统真的需要RPC来调用本地方法吗？其实只要能提供服务就行了）
* REST风格的不足和争议：
  * 登录和注销接口：抽象化一个session资源，登录是put、注销是delete
  * 自定义方法：[Google的REST](https://google-cloud.gitbook.io/api-design-guide/custom_methods)常用自定义方法有cancel/batchGet/move/search/undelete
  * 只查询用户的名称：REST默认返回用户的所有字段，实现此功能可以这样users/12?fields=name
  * 批量给1000个用户名加vip前缀：抽象化一个资源VIP-Modify-Task，然后传1000个用户id
  * 购物下单接口：涉及多个资源(用户、订单、库存、积分)的修改，抽象化一个资源来表示这个流程
* 事务处理之本地事务：靠支持事务的数据源如InnoDB来支持
* 事务处理之分布式事务
  * [分布式系统中的一致性与共识算法](http://www.xuyasong.com/?p=1970)
  * ACID专注于分布式事务；CAP和BASE是分布式通用理论
  * 2PC用于保证多个数据分片上事务的原子性，Paxos协议用于保证同一个数据在多个副本的一致性，两者是互补关系
  * 2PC的协调者可以通过Paxos协议来选出
  * 2PC和TCC
    * 2PC：准备阶段所有节点写redo日志和加锁，提交阶段所有节点commit
    * TCC(Try-Confirm-Cancel)：对业务有侵入性，在Try阶段对数据做冻结，Cancel阶段对数据做恢复
* 透明多级分流系统
  * [浏览器缓存原理](https://learnku.com/articles/43143)，浏览器先检查Cache-Control/Expire，过期则带上If-None-Match/If-Modified-Since请求服务器
  * 域名解析，有TTL缓存时间
  * 传输链路：H2之前使用雪碧图等等；Gzip压缩；使用H2或者H3
  * 内容分发：域名别名指向CDN厂商的glsb；CDN的主动推送或者被动回源
  * 负载均衡之mac层：三角传输(LB和server使用同一虚拟ip)，需在二层网络
  * 负载均衡之ip层：
    * 方案1：三角传输(LB和server使用同一虚拟ip，使用IP隧道)，非二层网络也行
    * 方案2：NAT模式，LB修改dIP把流量转发给server，server需配置网关地址为LB
    * 方案3：SNAT模式，LB修改dIP把流量转发给server(同时修改sIP为LB自己)，好处是server不需要配置网关，坏处是server看不到真实ip
  * 负载均衡之传输层：同ip层，可以根据传输协议(tcp/udp)转发
  * 负载均衡之应用层：nginx、haproxy
  * 服务器缓存：缓存淘汰策略(lru/lfu)，缓存穿透(db记录不存在)、缓存击穿(缓存过期了)、雪崩(db压力陡增)  
* 架构安全性
  * OAuth2.0授权
    * 授权码模式：需要有自己的应用服务器，与授权服务器交互2次，一次拿授权码，一次拿token
    * 隐式授权模式：不需要有自己的应用服务器，通过授权服务器跳转回的url拿token，例如gtalk
    * 密码模式：用户带用户名密码请求应用服务器，应用服务器带用户名密码请求授权服务器，要求应用服务器、授权服务器属于同一公司
    * 客户端模式：应用服务器直接通过clientId、clientSecret请求授权服务器获得token
  * 凭证：一般用session或者jwt
  * 传输：https
    
#### 第三部分，分布式的基石（如何隐藏技术细节使其不会干扰业务）

#### 第四部分 不可变基础设施

#### 技术方法论和随笔
